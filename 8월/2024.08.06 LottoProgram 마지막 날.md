## 1. 발표를 마치고 자체 피드백 
- 주고 받는 데이터 형식은 형식마다 클래스로 만들면 좋다.
	- ![](image/lottoData.jpg)
		- 번호 6개 정보와 enum 클래스 Mode 정보까지 담긴다.
	- ![](image/lottoReacord.jpg)
		- 하나의 클래스에 여러가지 정보를 담을 수 있다.
- GUI 구현에서는 선언과 초기화 (정확히는 불변하는 요소와 계속 바뀔 수 있는 요소를 나눠야 한다.) 
	- 라벨, 패널, 기능 하나마다 세세하게 나눌수록 좋다.
		- 하나를 수정하면 다른 컴포넌트가 영향을 받지 않기 위해
	- 전체 프로그램 흐름을 파악하기 좋게 만들면 좋다.
		- 특정 메서드 실행 순서가 바뀌면 에러가 뜨기 쉽다.
		- 서로 연결된 파일을 팀원과 나눠서 작업할 경우 초반에 토론으로 서로가 이해할 수 있는 틀을 잡고 가야 나중에 상대방이 작업한 파일 수정이 용이하다.
	- ![](image/엄청%20초창기%20코드1.jpg)
		- 선언과 초기화를 동시에 하면 화면전환을 구현할 시 컴포턴트를 통째로 지우고 다시 만드는 방법을 써야한다.
	- ![](image/선언%20부분.jpg)
		- ![](image/iniWinMoneyLbl.jpg)
		- 앞으로 변하지 않을 요소(폰트, 위치 등등)들을 모아두었다.
	- ![](image/초기화%20부분.jpg)
		- ![](image/setWinMoneyLbl.jpg)
		- winMoneyLagel의 텍스트를 정하는 부분을 분리
		- 화면 전환시 이 메서드만 실행시키면 된다.
- 컴포넌트(라벨 등)는 바로 contentsPane에 넣지 말고 패널에 담아서 패널을 집어 넣어야 한다.
	- 바로 추가해 버리면 다른 부분을 수정하면 위치가 영향 받기 쉽다
	- 각자 구역을 설정해 패널별로 묶어놓으면 수정도 편하고 위치 재조정도 편하다.

---
## 2. 선생님 피드백
- #### 전체 조 피드백
	- 고용량의 데이터나 파일은 불러올 때 시간이 많이 걸린다.
		- 로딩창이 있는 이유 중 하나
		- 근본적인 해결 방법은 이미지파일을 열화시켜야 한다. (해상도나 화질 감소)
		- gif는 큰 용량의 주범
			- 그래서 멈춘 사진을 먼저 로딩하고 그 다음 gif를 불러와서 그림을 움직이게 한다.
	- 소스 코드들은 최대한 잘게 쪼개야 한다.
		- 문제가 생길 경우 어느 부분에서 문제가 생겼는지 파악하기 좋다.
	- 함수의 반환형을 정하다 보니 2개 이상의 변수를 반환해야 한다.
		- 클래스가 필요한 상황
		- 클래스는 무작정 만드는게 아니라 필요할 때 만들어야 한다.
		- 관련있는 변수들을 묶어서(정보가 분산되지 않게) 클래스 파일을 만든다.
		- 필드값 선언(declaration)을 한 경우 Null참조가 일어나지 않게 초기화(initialization)를 해줘야 한다.
	- 새 문장을 쓰면 거기서 에러가 생길 수 있다
		- 문장 다음에 System.out.println("객체 상태 확인: " + input); 같은 코드로 확인을 해야한다.
	- 클래스를 사용하다 보면 복잡해진다.
		- 외부에서 쓰지 않는 메서드나 필드는 private으로 설정한다.
	- 보통 생성 / 입력 / 연산 / 출력 은 무조건 나눈다.
		- 출력 형태 변화 필요 -> 출력 메서드만 수정
		- 입력에서 예외 발생 -> 입력 메서드만 수정
	- 사용자는 프로그래머가 아니기 때문에 GUI의 G(Graphic)을 많이 쓰게 된다.
		- GUI는 출력하는 방법 중 하나일 뿐 프로그램의 핵심이 되어선 안된다.
		- GUI에 종속되는 기능은 지양해야 한다.
	- 여러 변수를 다루는 방법
		1) 배열 ( int\[] 같은 )
		2) 컬렉션(List, Set, Map)
			- 자주 쓰이는 형식이니까 자바 안에 미리 만들어져 있다.
			- 기능과 장점에 따라 3가지로 만들었다.
			- 장점 > 단점일 때 선택해서 쓰는 것이다.
	- JOptionPane은 사용을 지양해야 한다.
		- 창이 많이 뜨는 방식은 옛날 방식
		- 사용자가 싫어한다.
		- 요새는 흐름으로 구현
			- 새 창으로 보여주지 않고 화면이 전환된다.

---
- #### 우리 조 피드백
	- 외부파일은 resource패키지로 잘 분리 해놓고 클래스파일은 분류를 안했다. 화면끼리 연산(메서드)끼리 자료끼리 패키지로 분리해서 묶어둘 것.
	- showDialog로 함수명 통일한 것은 좋았다. 여러 명 같이 작업할 때 유용하다.
	- 컴포넌트를 패널에 담았어야 했다. 앱솔루트 레이아웃은 적용할 때마다 좌표를 계산해야 하는 번거로움이 있다.
		- absolute 레이아웃을 쓰지 말라는 말이 아니다.
		- ![](image/우리가%20나눈%20방식.jpg)
			- 우리가 작업하면서 구분했던 방식
			- 패널로 구분한 것도 아니고 for 반복문으로 5줄 모두 생기도록 묶여있었다.
		- ![](image/선생님이%20추천하는%20패널구성.jpg)
			- 가로로 1줄을 1개의 패널에 묶어 놨으면 이 출력 형태를 재활용 시 편했을 것.
			- 번호만 묶은 패널도 만들었으면 잘 써먹었을 것.
			- 번호만 묶은 패널을 위의 1줄 패널에 넣어서 썼어야 했다.
			- 패널 안에서 앱솔루트 레이아웃으로 위치를 설정해두면 이 패널만 가지고 다른 곳에서 복잡한 좌표 계산 없이 쓸 수 있다..
- #### 여러 메서드들을 적다 보니 StudentIO처럼 입출력 메서드끼리 묶듯 메서드 묶음 클래스를 만들까 했다.
	- 현업에서는 메서드 1개당 1개의 클래스로 작성한다.
	- 클래스 파일명을 메서드 이름으로 하다보니, 클래스 파일 안의 소스 코드보다 파일명이 더 길어지기도 한다.
		- 요새 프로그램들은 컨트롤 클릭 같은 추적기능이 잘 구현되어 있어서 따라가기 쉽다.
		- 구글이 20억개의 파일로 이루어져 있다.
- #### 앞으로의 피드백 반영을 위해 소스 코드를 엎는 일은 현업에서는 거의 없다.
	- 현역 프로그래머는 처음부터 엎는 일이 생길 정도의 코드를 작성하지 않는다.
	- 기반 정보가 바뀔 때는 엎기도 한다. 자바 8을 쓰다가 17로 넘어가는 상황 같을 때.
	- 아주 오래된 언어(코볼 같은)를 40년 쓰고 그런다.
		- 그러다 보니 해당 언어를 다루는 프로그래머가 다 은퇴하면 곤란해진다.
		- 이런 단점이 있음에도 소스 코드를 엎는 일은 현업에서는 거의 없다.
- #### 클라이언트의 피드백
	- 변덕이 심한 클라이언트는 피드백도 잦고 내용도 바뀐다.
		- 기록을 잘 남겨놔야 한다. 클라이언트의 결제를 받았다는 문서.
		- 클라이언트가 시켜놓고 까먹고 나중에 이 기능 왜 추가했어요? 이러기도 한다.
		- 사적 카톡은 클라이언트랑 나누지 않는 게 좋다.
			- 클라이언트가 변덕을 부리기 좋은 상황
- ##### enum 클래스로 그림 객체(아이콘)를 6개만 만들어서 돌려 막은 것은 좋았다.
	- 아이콘 하나 쓸 때 마다 이미지 객체가 1개 생성되면 좋지 않다.

---
