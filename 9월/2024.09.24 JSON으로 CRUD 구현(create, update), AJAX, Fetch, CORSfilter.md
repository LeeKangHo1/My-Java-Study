## 1. JSON으로 CRUD 구현(create, update)
- create는 doPost, update는 doPut, read는 doGet, delete는 doDelete로 구현
	- 정해진 건 아니나 보통 이렇게 한다.
- #### create를 doPost로 구현
	- ![](image/json%20insert.jpg)
		- req.getAttribute("coffee");는 필터에서 받아온다.
		- ![](image/create%20update%20json.jpg)
			- 전송 방식(method, post or put)으로 구분
			- req에서 parsingJson 메서드로 json정보를 객체로 변환
			- Coffee객체를 req에 저장
			- ![](image/parsingJson.jpg)
- #### update를 doPut으로 구현
	- ![](image/json%20update12.jpg)
		- req에서 Coffee객체 받아 오는 건 필터에서. 
- #### CoffeeService의 updateCoffee, insertCoffee
	- ![](image/coffee%20service%20updatecoffee%20insertcoffee.jpg)
---
## 2. postman으로 json crud 테스트
- ![](image/postman으로%20put%20테스트%20body%20raw%20json.jpg)
	- json 정보를 테스트
	- Params가 아니라 Body로 간다.
	- raq를 선텍하고 JSON을 선택한다.
	- json 형식으로 body를 작성한다.
	- send

---
## 3. AJAX, Fetch, SSR, CSR
- ### AJAX (Asynchronous JavaScript and XML)
	- 웹 페이지에서 서버와 비동기적으로 데이터를 주고받는 기술
	- 페이지 전체를 새로고침하지 않고 필요한 데이터만 서버로부터 받아서 웹 페이지의 일부를 업데이트
	- 특징
		- 비동기성: 서버에 요청을 보내도, 웹 페이지는 멈추지 않고 다른 작업을 계속할 수 있음.
		- 부분 업데이트: 페이지 전체가 아닌, 일부분만 데이터를 받아서 동적으로 업데이트 가능.
		- 다양한 데이터 포맷 지원: XML뿐만 아니라 JSON, HTML 등 다양한 형식으로 데이터를 주고받을 수 있음.
	- SSR이 아닌 CSR 방식이라 일부분의 데이터를 받기 위한 요청을 사용자 모르게(대표적으로 화면 깜빡임이 없다)전송
	- XMLHHttpRequest 나 fetch로 구현 가능
- ### SSR (Server-Side Rendering)
	- 서버가 요청을 받으면, 모든 데이터를 처리하여 최종적인 HTML을 만들어 클라이언트에게 전달
		- 사용자가 페이지를 처음 방문할 때 전체 페이지가 이미 렌더링된 상태로 제공된다.
	- SEO(Search Engine Optimization, 검색 엔진 최적화)에 유리하고 초기 로드가 빠르다.
- ### CSR (Client-Side Rendering)
	- 클라이언트(브라우저) 측에서 JavaScript를 사용하여 페이지를 렌더링하는 방식
		- 처음에는 빈 HTML 페이지가 로드되고, 필요한 데이터와 함께 JavaScript 코드가 실행되면서 화면이 구성된다.
	- 페이지가 한 번 로드된 이후에는 사용자 요청에 따라 화면이 부분적으로만 변경되는 방식

---
## 4. Fetch API
- javascript 내장 함수, 서버에 네트워크 요청을 보내고 응답을 받을 수 있는 최신 방식이다.
- promise(약속)을 기반으로 더 간결하고 직관적으로 비동기 작업을 처리 가능
- 비동기적 흐름으로 진행되기 때문에 동기적 흐름(일반적인 소스코드가 위에서 부터 아래로 하나하나 실행되는)과 따로 실행된다. -> CSR
- JSON으로 구현한 api로 do(Get,Post,Put,Delete) 만들어야 사용 가능, 설정이 없을 경우 Get으로 간주한다.
- JavaScript(.js)로 작성한다.
- #### HTML로 json 정보 출력할 준비
	- ![](image/fetch%20html.jpg)
		- 복제(clone)를 위한 template 태그 사용
- #### fetch로 CRUD의 read 구현
	- ![](image/fetch%20reload%20read.jpg)
	- fetch("url", { method: "방식" }).then((response) => { 실행할 문장1 }).then((arr) => { 실행할 문장2 });
		- fetch의 기본 형식(약속, promise)이다.
		- url은 api 서블릿의 url mapping 주소
		- { method: ""} 생략 시 get방식
		- .then으로 이어주면 차례차례 실행, 화살표 함수(arrow function)를 써야 한다.
		- .then((arr) => {}) 형식이 가능한 이유는 js(javascript)라 파라미터의 type 정의가 필요 없기 때문. response.json()이 arr이 된다.
- #### fetch로 CRUD의 delete 구현
	- ![](image/fetch%20로%20delete.jpg)
		- target.previousElementSibling;
			- 타겟의 형제 요소 선택
		- delete는 method: "delete" 설정해주고 body는 설정 필요 없다.
		- container.replaceChildren();
			- 파라미터값이 없을 경우 자식요소를 다 지운다.
		- reload();
			- 위에 fetch로 구현한 read를 함수로 만든 것
- #### fetch로 CRUD의 create 구현
	- ![](image/fetch%20로%20create.jpg)
		- e.preventDefault();
			- 제출 버튼을 눌렀을 때 form이 전달 되는 것을 멈춤
		- form을 FormData 객체로 바꾼다.
		- JSON.stringify(Object.fromEntries(formdata));
			- formdata(key,value로 이루어진 데이터)를 객체로 만든 다음 json문자열로 바꾼다.
		- method는 post, body는 json으로 설정해야 한다.
		- status code가 201인 경우가 제대로 전송 된 것
			- form.reset()으로 입력값을 지운다.(지우지 않으면 아까 적은 값이 제출 버튼 눌러도 남아있다.)
		- 출력된 내용을 지우고 reload();로 다시 불러온다.
- fetch update는 생략

---
## 5. fetch로 회원가입에서 아이디 중복 체크하기
- #### 중복 체크할 화면 html로 구성
	- ![](image/fetch%20회원가입.jpg)
	- ![](image/error%20와%20hidden%20클래스의%20css%20설정.jpg)
- #### 중복체크를 api와 .js로 구현
	- ![](image/fetch%20아이디%20중복체크에%20쓰일%20서블릿.jpg)
		- response의 헤더를 설정해야 한다.
			- text/plain는 일반적인 text
		- status code 대신 글자가 response에 남도록(f12의 네트워크 탭에 리퀘스트 name 누르고 response탭에 가면 남는 글자)
	- ![](image/fetch로%20아이디%20중복%20체크.jpg)
		- "\http://localhost:8080/240913web/api/v1/userinfo" + query 를 get으로 보내면 UserinfoAPI서블릿의 doGet이 실행
		- resp.text();
			- response에서 getWriter()로 얻은 PrintWriter로 print한 내용을 불러온다.
			- text내용에 따라 idOk(사용가능한 아이디입니다.) or duplicate(사용할 수 없는 아이디입니다.) 내용을 보이게 만든다.
				- 제출 버튼도 비활성화 or 활성화 된다.
		- ![](image/키보드%20입력%20시%20제출버튼%20봉인%20풀리게.jpg)
			- 아이디를 쓰고 중복확인을 눌러서 사용가능한 아이디입니다. 메세지가 뜨면 제출 버튼이 활성화 된다.
				- 아이디를 바꾸려고 키보드를 누르면 제출 버튼이 비활성화된다.
				- 중복확인을 누르고 아이디를 바꿔서 중복확인 안누르고 바로 제출 누르는 꼼수를 방지한다.

---
## 6. CORS (Cross-Origin Resource Sharing) 설정하기
- 이클립스에서 파일을 open with로 비주얼 스튜디오에서 연 다음 live preview 기능을 쓰면 CORS policy가 뜨면서 화면이 제대로 출력되지 않는다.
	- 톰캣은 8080 포트를 쓰고 라이브 프리뷰는 3000 포트를 쓰는데 권한 설정을 해주지 않으면 서버를 넘어가는 것은 기본적으로 차단된다.
	- 비주얼 스튜디오(visual studio)에서 갑자기 라이브 프리뷰가 되지 않을 경우 Extensions에서 Live Preview에 톱니바퀴 옆 느낌표 모양을 클릭한 다음 trust를 눌러야 한다.
		- Ctrl + Shift + p로 라이브 프리뷰(external browser) 가능
		- ![](image/visual%20studio%20trust%20화면.jpg)
- ![](image/CORS%20filter%20설정.jpg)
	- 권한을 주려면 응답헤더(response header)세팅을 바꿔야 한다.
		- 헤더세팅은 mdn cors resource 검색 Cross-Origin Resource Sharing (CORS) - MDN Web Docs 에서 확인한다.
- ![](image/CORS%20filter%20web%20xml에%20적용.jpg)
	- /api/*
		- /api/ 하위 경로 모두에게 적용

---
#### tips
- 이클립스에서 js파일 비주얼스튜디오로 편집하기
	- 파일 우클릭 -> open with -> ohters -> visual studio 검색
	- ![](image/비쥬얼%20스튜디오로%20html%20편집하기%20open%20with%20external%20programs.jpg)
	- external programs 선택

---
